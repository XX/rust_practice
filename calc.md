# Калькулятор

## Как пользоваться этим уроком

Вам предлагается разработать программу для решения одной четко поставленной задачи, поэтапно, следуя рекомендациям. Урок рассчитан на строго последовательное выполнение, без пропусков, и ориентирован прежде всего на практическое обучние самостоятельному решению задач программирования на Rust. При разработке своих решений, помимо собственной головы, вы можете пользоваться встроенной справкой, любыми поисковиками, документацией к используемым библиотекам, а также всевозможными форумами и чат-каналами прежде, чем заглянуть в ответы. Все ответы на основные и дополнительные задания приведены в конце урока, по каждому нумерованному параграфу. Обращайтесь к ответам для проверки своего решения или в крайнем случае, если вы зашли в совершеннейший тупик и выйти из него вам ничто другое помочь не в состоянии. 

## Постановка задачи

Необходимо разработать консольную программу-калькулятор, способную вычислять простые арифметические выражения. Выражения могут содержать целые и действительные числа (дробная часть от целой отделяется точкой), операции сложения `+`, вычитания `-`, умножения `*`, деления `/`, возведения в степень `^`, функции `cos` и `sin`, а также скобки `()`, изменяющие порядок вычисления. Программа должна принимать выражение через аргументы командной строки и выводить результат вычисления в стандартный поток вывода.

Дополнительно должен быть предусмотрен режим интерактивной работы (REPL - read-eval-print loop, цикл "чтение — вычисление — вывод"), в котором выражения можно вводить последовательно, каждое на новой строке, а программа должна выводить результат вычисления каждой такой строки. В интерактивном режиме должна поддерживаться возможность присваивать значения выражений переменным, чтобы дальше их можно было использовать в новых выражениях. Выход из программы должен осуществляться по команде `quit`.

Примеры работы программы:

```sh
$ calc 1 + 2
3

$ calc 1-2*3
-5

$ calc 'cos(1) + 1.5 * 10'
15

$ calc '(2.2 + 2.8)/5'
1

$ calc --repl
> x = 1 + 2
3
> x * 1.5
4.5
> quit
```

## Этапы реализации

### 1. Создание проекта

#### 1.1

Заведите новый проект с названием `calc`, настройте среду разработки для работы с этим проектом. Чтобы быстро создать новый проект, воспользуйтесь командой `cargo new`. Убедитесь, что ваш проект компилируется и запускается. Для этого в директории проекта выполните команды:

```sh
$ cargo run
Hello, world!

$ ./target/debug/calc
Hello, world!
```

[Решение](#11-1)

#### 1.2

Определим общий алгоритм работы программы. По сути она должна представлять собой простой интерпретатор, который будет работать по следующему алгоритму:

1. Прочитать входную инструкцию;
2. Проанализировать инструкцию и определить необходимые действия;
3. Выполнить действия;
4. Если не достигнуто условие завершения программы, то перейти к шагу 1.
    
Первая версия калькулятора не будет предоставлять интерактивной оболочки, а значит для нее нам не потребуется реализация шага 4. В качестве инструкций ей на вход будет передаваться арифметическое выражение через аргументы командной строки (шаг 1), требуемое действие будет заключаться в вычислении входного выражения и выводе результата на консоль (шаг 3), после чего программа будет завершаться.

Вторая, расширенная версия, будет принимать инструкции через стандартный консольный ввод и в качестве инструкций, помимо выражений, будет понимать также команду присваивания значения выражения переменной и команду окончания работы программы. Для этой версии программы уже потребуется реализация шага 4.


### 2. Работа с аргументами командной строки

#### 2.1

Прочитайте переданные программе аргументы командной строки и выведите их на консоль. Чтобы понять, как работать с аргументами командной строки в Rust, вы можете почитать документацию к функции [`std::env::args`](https://doc.rust-lang.org/std/env/fn.args.html) из стандартной библиотеки Rust и/или раздел [Accepting Command Line Arguments](https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html) официальной книги [The Rust Programming Language][rust_book].

Убедитесь, что программа корректно читает и выводит свои аргументы. Например так:

```sh
$ cargo run -- test 1 2
target/debug/calc
test
1
2

$ ./target/debug/calc test 1 2
./target/debug/calc
test
1
2
```

*Дополнительно*

 - Почему при запуске программы через `cargo` мы должны передавать ей аргументы после разделителя `--`? Найдите ответ во встроенной справке утилиты `cargo`.

#### 2.2

Склейте все переданные аргументы, кроме имени программы, в одну строку и напечатайте ее.

Для проверки выполните:
    
```sh
$ cargo run -- test 1 2
test12

$ cargo run -- 1 + 2
1+2
```

*Дополнительно*

 - Функция `std::env::args` возвращает итератор по переданным аргументам, а метод [`collect`](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect) итератора по строкам может собрать их в одну строку. Если вы реализовали склеивание другим способом, то переделайте его так, чтобы склеивание осуществлялось с помощью методов итератора.

 - Почему выполнение команды `cargo run -- 1 * 2` приводит к неожиданному результату (в bash), а команды `cargo run -- 1*2` или `cargo run -- '1 * 2'` не приводит? Почему в последнем случае в выводе программы знак умножения также обрамлен пробелами?

#### 2.3

Измените код программы таким образом, чтобы переданные аргументы склеивались в одну строку с добавлением пробелов между собой. Используйте для этого метод [`join`](https://doc.rust-lang.org/std/primitive.slice.html#method.join), доступный для срезов. Однако вам придется подумать, в какой тип вы можете собрать методом `collect` итератор, чтобы потом на него можно было смотреть как на срез.

Для проверки выполните:
    
```sh
$ cargo run -- test 1 2
test 1 2

$ cargo run -- 1 + 2
1 + 2
```

### 3. Разбор выражений

#### 3.1

Мы научились читать входное выражение, теперь необходимо его разобрать. В интерпретаторах (и компиляторах) подобный разбор обычно выполняется в два этапа:

 - Лексический анализ
 - Синтаксический анализ

Сначала на этапе лексического анализа мы выделяем из входного потока символов отдельные лексемы (числа, знаки операций, вызовы функций) и представляем их в виде потока токенов, то есть слов, соответствующего лексемам типа. Полученный поток токенов передается синтаксическому анализатору - парсеру, - который строит так тазываемое дерево разбора выражения и определяет его корректность (например, соблюдение правильной последовательности открывающих и закрывающих скобок).

Рассмотрим запись вида:

```
John Smith, male, 25
```

Она может быть представлена следующим потоком токенов:

```
NAME "John Smith"
COMMA
MALE
COMMA
NUMBER "25"
```

Взятых из списка возможных токенов для подобных записей, например такого:

```
NAME name
NUMBER value
MALE
FEMALE
COMMA
```

Некоторые токены кроме идентификатора должны содержать и само значение (лексему) из входной строки разбора (например токен `NAME`), тогда как для других достаточно просто идентификатора (такокго как `COMMA`).

Составьте список возможных токенов для инструкций калькулятора, ориентируясь на требования к работе программы из постановки задачи.

#### 3.2

Приступите к реализации лексического анализатора.  Пусть он будет представлен отдельной функцией `tokenize`, которая на вход принимает строковый срез входной последовательности символов, а на выходе выдает набор (`Vec`) токенов. Сами токены будут представлены вариантами перечисления `enum Token`, соответствующими записям вашего списка токенов, исключая те, что относятся к работе в интерактивном режиме (они будут добавлены позже).

Лексер калькулятора очень простой, его работа осуществляется в две стадии: сканирование и оценка.

На первой стадии лексер анализирует последовательно входные символы, и как только встречает первый непробельный символ, по его значению определяет тип токена, который с него начинается. Далее он вычитывает все символы, которые могут составлять данный токен до тех пор, пока не наткнется на символ, который не может входить в данный токен. Затем лексер оценивает прочитанную последовательность символов для данного токена, и если нужно сохраняет извлеченное из нее значение. После этого процедура повторяется для следующего токена, пока не будет достигнут конец входной последовательности.

Реализуйте функцию-лексер и тип `Token`. Найдите способ получить итератор для итерирования по отдельным символам строкового среза, методы для определения типа символа (пробельный символ, число или конкретный симов, как точка или знак арифметической операции), а также способ парсинга из строки числа с плавающей точкой. Для типа `Token` реализуйте типаж `Debug` для возможности вывода полученных результатов на консоль.

Пример работы программы, для проверки результата:


#### 3.3

```sh
$ cargo run -- -1 +2 3
[Minus, Number(1.0), Plus, Number(2.0), Number(3.0)]

$ cargo run -- '+1 -2 34*5 / 6.78 ) 9 ( sin cos'
[Plus, Number(1.0), Minus, Number(2.0), Number(34.0), Mul, Number(5.0), Div, Number(6.78), ClosePar, Number(9.0), OpenPar, Name("sin"), Name("cos")]
```


### 4. Автоматическое тестирование

### 5. Интерактивный режим работы

### 6. Переменные

## Набор тестов

## Пример решения

### 1.1 

```sh
$ cargo new --bin calc
     Created binary (application) `calc` package

$ cd calc

$ cargo run
   Compiling calc v0.1.0 (/home/user/calc)
    Finished dev [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/calc`
Hello, world!

$ ./target/debug/calc 
Hello, world!
```

### 2.1

Файл `src/main.rs`:

```rust
use std::env;

fn main() {
    for argument in env::args() {
        println!("{}", argument);
    }
}
```

Работа программы:

```sh
$ cargo run -- test 1 2
target/debug/calc
test
1
2

$ ./target/debug/calc test 1 2
./target/debug/calc
test
1
2
```

Ответ на вопрос о передачи аргументов запускаемой через `cargo` программе, легко прочитать во встроенной справке утилиты `cargo` для команды `run`:

```sh
$ cargo help run
```
```
NAME
       cargo-run - Run the current package

SYNOPSIS
       cargo run [options] [-- args]

DESCRIPTION
       Run a binary or example of the local package.

       All the arguments following the two dashes (--) are passed to the binary
       to run. If you're passing arguments to both Cargo and the binary, the ones
       after -- go to the binary, the ones before go to Cargo.
```

### 2.2

Файл `src/main.rs`:

```rust
use std::env;

fn main() {
    let expression: String = env::args().skip(1).collect();
    println!("{}", expression);
}
```

Работа программы:

```sh
$ cargo run -- test 1 2
test12

$ cargo run -- 1 + 2
1+2
```

Запуск программы с параметрами `1 * 2` может приводить к странному выводу:

```sh
$ cargo run -- 1 * 2
1Cargo.lockCargo.tomlsrctarget2
```

Это происходит потому, что некоторые символы в команде интерпретируются командной оболочкой как специальные и в частности отдельная звездочка `*` будет воспринята оболочкой как команда "подставить на это место список файлов текущей директории", то есть в нашем случае аналог:

```sh
$ cargo run -- 1 Cargo.lock Cargo.toml src target 2
```

Чтобы этого не произошло, специальный символ нужно экранировать:

```sh
$ cargo run -- 1 \* 2
1*2

$ cargo run -- 1 '*' 2
1*2

$ cargo run -- '1 * 2'
1 * 2
```

В последнем случае мы с помощью кавычек экранировали вообще все выражение, включая пробелы, поэтому в таком случае оно передается целиком как один аргумент командной строки.

### 2.3

Файл `src/main.rs`:

```rust
use std::env;

fn main() {
    let args: Vec<_> = env::args().skip(1).collect();
    let expression = args.join(" ");
    println!("{}", expression);
}
```

Работа программы:

```sh
$ cargo run -- test 1 2
test 1 2

$ cargo run -- 1 + 2
1 + 2
```

### 3.1

```
NUMBER value
PLUS
MINUS
MULTIPLICATION
DIVISION
POWER
NAME name
OPEN_PARENTHESIS
CLOSE_PARENTHESIS
REPL
ASSIGNMENT
QUIT
```



[rust_book]: https://doc.rust-lang.org/stable/book/
